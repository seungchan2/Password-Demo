//
//  PatternViewModel.swift
//  Password-Demo-App
//
//  Created by MEGA_Mac on 9/18/25.
//

//
//  ViewModelType.swift
//  Password-Demo-App
//
//  Created by MEGA_Mac on 9/18/25.
//

import UIKit

import SnapKit
import RxSwift
import RxCocoa

final class PatternViewModel: ViewModelType {
        
    struct Input {
        let viewDidLoad: Observable<Void>
        let patternCompleted: Observable<[Int]>
        let deletePatternTapped: Observable<Void>
        let showSecurityInfoTapped: Observable<Void>
        let backButtonTapped: Observable<Void>
        let timerTick: Observable<Void>
    }
    
    struct Output {
        let uiMode: Driver<UIMode>
        let statusText: Driver<String>
        let statusColor: Driver<UIColor>
        let securityInfoText: Driver<String>
        let showAlert: Driver<AlertModel>
        let dismissViewController: Driver<Void>
        let isPatternInteractionEnabled: Driver<Bool>
        let isDeleteButtonHidden: Driver<Bool>
        let shouldResetPattern: Driver<Void>
    }
        
    private let patternManager: SecurePatternManagerProtocol
    private let disposeBag = DisposeBag()
        
    private let uiModeRelay = BehaviorRelay<UIMode>(value: .registration)
    private let alertRelay = PublishRelay<AlertModel>()
    private let dismissRelay = PublishRelay<Void>()
    private let resetPatternRelay = PublishRelay<Void>()
    
    
    init(patternManager: SecurePatternManagerProtocol = SecurePatternManagerFactory.createDefault()) {
        self.patternManager = patternManager
    }
        
    func transform(input: Input) -> Output {
        
        input.viewDidLoad
            .subscribe(with: self) { owner, _ in
                owner.checkInitialSecurityStatus()
            }
            .disposed(by: self.disposeBag)
        
        input.patternCompleted
            .subscribe(with: self) { owner, pattern in
                owner.handlePatternCompleted(pattern)
            }
            .disposed(by: self.disposeBag)
        
        input.deletePatternTapped
            .subscribe(with: self) { owner, _ in
                owner.deletePattern()
            }
            .disposed(by: disposeBag)
        
        input.showSecurityInfoTapped
            .subscribe(with: self) { owner, _ in
                owner.showSecurityInfo()
            }
            .disposed(by: self.disposeBag)
        
        input.backButtonTapped
            .subscribe(with: self) { owner, _ in
                owner.dismissRelay.accept(())
            }
            .disposed(by: self.disposeBag)
        
        input.timerTick
            .subscribe(with: self) { owner, _ in
                owner.updateSecurityStatus()
            }
            .disposed(by: self.disposeBag)
        
        let statusText = uiModeRelay.asDriver()
            .map { [weak self] mode -> String in
                return self?.updateStatusText(for: mode) ?? ""
            }
        
        let statusColor = uiModeRelay.asDriver()
            .map { [weak self] mode -> UIColor in
                return self?.updateStatusColor(for: mode) ?? .systemYellow
            }
        
        let securityInfoText = uiModeRelay.asDriver()
            .map { [weak self] _ -> String in
                return self?.updateSecurityInfoText() ?? ""
            }
        
        let isPatternInteractionEnabled = uiModeRelay.asDriver()
            .map { mode in
                return mode != .locked
            }
        
        let isDeleteButtonHidden = uiModeRelay.asDriver()
            .map { mode in
                return mode != .verification
            }
        
        return Output(
            uiMode: uiModeRelay.asDriver(),
            statusText: statusText,
            statusColor: statusColor,
            securityInfoText: securityInfoText,
            showAlert: alertRelay.asDriver(onErrorJustReturn: AlertModel.defaultAlert),
            dismissViewController: dismissRelay.asDriver(onErrorJustReturn: ()),
            isPatternInteractionEnabled: isPatternInteractionEnabled,
            isDeleteButtonHidden: isDeleteButtonHidden,
            shouldResetPattern: resetPatternRelay.asDriver(onErrorJustReturn: ())
        )
    }
        
    private func checkInitialSecurityStatus() {
        let securityInfo = patternManager.getSecurityInfo()
        let isLocked = securityInfo["Í≥ÑÏ†ï Ïû†ÍπÄ"] as? Bool ?? false
        let isPatternSet = patternManager.isPatternSet()
        
        if isLocked {
            uiModeRelay.accept(.locked)
        } else if isPatternSet {
            uiModeRelay.accept(.verification)
        } else {
            uiModeRelay.accept(.registration)
        }
    }
    
    private func updateSecurityStatus() {
        let securityInfo = patternManager.getSecurityInfo()
        let isLocked = securityInfo["Í≥ÑÏ†ï Ïû†ÍπÄ"] as? Bool ?? false
        let currentMode = uiModeRelay.value
        
        if isLocked && currentMode != .locked {
            uiModeRelay.accept(.locked)
        } else if !isLocked && currentMode == .locked {
            uiModeRelay.accept(.verification)
        }
    }
    
    private func handlePatternCompleted(_ pattern: [Int]) {
        let securityInfo = patternManager.getSecurityInfo()
        let isLocked = securityInfo["Í≥ÑÏ†ï Ïû†ÍπÄ"] as? Bool ?? false
        
        guard !isLocked else { return }
        
        if patternManager.isPatternSet() {
            verifyPattern(pattern)
        } else {
            handlePatternRegistration(pattern)
        }
    }
    
    private func handlePatternRegistration(_ pattern: [Int]) {
        guard pattern.count >= 4 else {
            alertRelay.accept(AlertModel(
                title: "Ìå®ÌÑ¥ Ïò§Î•ò",
                message: "ÏµúÏÜå 4Í∞ú Ïù¥ÏÉÅÏùò Ï†êÏùÑ Ïó∞Í≤∞Ìï¥Ï£ºÏÑ∏Ïöî.",
                completion: { [weak self] in
                    self?.resetPatternRelay.accept(())
                }
            ))
            return
        }
        
        patternManager.savePattern(pattern)
        
        alertRelay.accept(AlertModel(
            title: "Ìå®ÌÑ¥ Ï†ÄÏû• ÏôÑÎ£å",
            message: "ÏÉà Ìå®ÌÑ¥Ïù¥ ÏïàÏ†ÑÌïòÍ≤å Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.",
            completion: { [weak self] in
                self?.uiModeRelay.accept(.verification)
                self?.resetPatternRelay.accept(())
            }
        ))
    }
    
    private func verifyPattern(_ pattern: [Int]) {
        if patternManager.verifyPattern(pattern) {
            alertRelay.accept(AlertModel(
                title: "Ïù∏Ï¶ù ÏÑ±Í≥µ",
                message: "Ìå®ÌÑ¥Ïù¥ ÏùºÏπòÌï©ÎãàÎã§!",
                completion: { [weak self] in
                    self?.resetPatternRelay.accept(())
                }
            ))
        } else {
            let securityInfo = patternManager.getSecurityInfo()
            let attemptCount = securityInfo["Ïã§Ìå® ÌöüÏàò"] as? Int ?? 0
            let maxAttempts = securityInfo["ÏµúÎåÄ ÏãúÎèÑ ÌöüÏàò"] as? Int ?? 5
            let isLocked = securityInfo["Í≥ÑÏ†ï Ïû†ÍπÄ"] as? Bool ?? false
            let remaining = maxAttempts - attemptCount
            
            if isLocked {
                uiModeRelay.accept(.locked)
                let lockoutTime = securityInfo["ÎÇ®ÏùÄ Ïû†Í∏à ÏãúÍ∞Ñ(Ï¥à)"] as? Int ?? 0
                alertRelay.accept(AlertModel(
                    title: "Í≥ÑÏ†ï Ïû†Í∏à",
                    message: "ÏµúÎåÄ ÏãúÎèÑ ÌöüÏàòÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§. \(lockoutTime)Ï¥à ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
                    completion: { [weak self] in
                        self?.resetPatternRelay.accept(())
                    }
                ))
            } else {
                alertRelay.accept(AlertModel(
                    title: "Ïù∏Ï¶ù Ïã§Ìå®",
                    message: "Ìå®ÌÑ¥Ïù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.\nÎÇ®ÏùÄ ÏãúÎèÑ ÌöüÏàò: \(remaining)Ìöå",
                    completion: { [weak self] in
                        self?.resetPatternRelay.accept(())
                    }
                ))
            }
        }
    }
    
    private func deletePattern() {
        alertRelay.accept(AlertModel(
            title: "Ìå®ÌÑ¥ ÏÇ≠Ï†ú",
            message: "Ï†ÄÏû•Îêú Ìå®ÌÑ¥Í≥º Î™®Îì† Î≥¥Ïïà Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
            style: .actionSheet,
            actions: [
                AlertAction(title: "Ï∑®ÏÜå", style: .cancel),
                AlertAction(title: "ÏÇ≠Ï†ú", style: .destructive) { [weak self] in
                    self?.patternManager.deletePattern()
                    self?.uiModeRelay.accept(.registration)
                    print("üóëÔ∏è [ViewModel] Ìå®ÌÑ¥ ÏÇ≠Ï†ú ÏôÑÎ£å")
                }
            ]
        ))
    }
    
    private func showSecurityInfo() {
        let securityInfo = patternManager.getSecurityInfo()
        var message = ""
        for (key, value) in securityInfo {
            message += "\(key): \(value)\n"
        }
        
        alertRelay.accept(AlertModel(
            title: "Î≥¥Ïïà ÏÉÅÌÉú Ï†ïÎ≥¥",
            message: message
        ))
    }
    
    private func updateStatusText(for mode: UIMode) -> String {
        switch mode {
        case .registration:
            return "ÏÉà Ìå®ÌÑ¥ÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî (ÏµúÏÜå 4Í∞ú Ï†ê)"
        case .verification:
            return "Ìå®ÌÑ¥ÏùÑ ÏûÖÎ†•ÌïòÏó¨ Ïù∏Ï¶ùÌïòÏÑ∏Ïöî"
        case .locked:
            let securityInfo = patternManager.getSecurityInfo()
            let remainingTime = securityInfo["ÎÇ®ÏùÄ Ïû†Í∏à ÏãúÍ∞Ñ(Ï¥à)"] as? Int ?? 0
            return "Ïû†Í∏à Ìï¥Ï†úÍπåÏßÄ \(remainingTime)Ï¥à ÎÇ®Ïùå"
        }
    }
    
    private func updateStatusColor(for mode: UIMode) -> UIColor {
        return mode.color
    }
    
    private func updateSecurityInfoText() -> String {
        let info = patternManager.getSecurityInfo()
        let attemptCount = info["Ïã§Ìå® ÌöüÏàò"] as? Int ?? 0
        let isLocked = info["Í≥ÑÏ†ï Ïû†ÍπÄ"] as? Bool ?? false
        let hasPattern = info["Ìå®ÌÑ¥ ÏÑ§Ï†ïÎê®"] as? Bool ?? false
        let maxAttempts = info["ÏµúÎåÄ ÏãúÎèÑ ÌöüÏàò"] as? Int ?? 5
        
        var infoText = ""
        if hasPattern {
            infoText += "Ìå®ÌÑ¥ ÏÑ§Ï†ïÎê® | "
        }
        if isLocked {
            infoText += "Í≥ÑÏ†ï Ïû†Í∏à ÏÉÅÌÉú | "
        }
        infoText += "Ïã§Ìå®: \(attemptCount)/\(maxAttempts)"
        
        return infoText
    }
}



